[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "자료구조",
    "section": "",
    "text": "들어가기",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#자료구조란-무엇인가",
    "href": "index.html#자료구조란-무엇인가",
    "title": "자료구조",
    "section": "자료구조란 무엇인가?",
    "text": "자료구조란 무엇인가?\n\n자료구조의 정의와 중요성\n자료구조와 알고리즘의 관계\n자료구조 선택의 기준",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#배열-array",
    "href": "index.html#배열-array",
    "title": "자료구조",
    "section": "배열 (Array)",
    "text": "배열 (Array)\n\n배열의 개념과 구조\n배열의 특징\n\n고정 크기\n인덱스를 통한 접근\n\n배열의 종류\n\n1차원 배열\n2차원 배열\n다차원 배열\n\n배열의 기본 연산\n\n삽입\n삭제\n검색\n수정\n\n배열의 장단점\n배열 사용 예제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#연결-리스트-linked-list",
    "href": "index.html#연결-리스트-linked-list",
    "title": "자료구조",
    "section": "연결 리스트 (Linked List)",
    "text": "연결 리스트 (Linked List)\n\n연결 리스트의 개념과 구조\n연결 리스트의 종류\n\n단일 연결 리스트\n이중 연결 리스트\n환형 연결 리스트\n\n연결 리스트의 기본 연산\n\n삽입\n삭제\n검색\n\n배열과 연결 리스트의 비교\n연결 리스트 사용 예제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#스택-stack",
    "href": "index.html#스택-stack",
    "title": "자료구조",
    "section": "스택 (Stack)",
    "text": "스택 (Stack)\n\n스택의 개념과 구조\nLIFO(Last In First Out) 원리\n스택의 기본 연산\n\npush (삽입)\npop (삭제)\npeek (조회)\n\n스택의 활용 사례\n\n괄호 검사\n함수 호출 관리 (콜 스택)\n\n배열과 연결 리스트로 구현하는 스택\n스택 사용 예제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#큐-queue",
    "href": "index.html#큐-queue",
    "title": "자료구조",
    "section": "큐 (Queue)",
    "text": "큐 (Queue)\n\n큐의 개념과 구조\nFIFO(First In First Out) 원리\n큐의 종류\n\n일반 큐\n원형 큐\n덱(Deque, 양방향 큐)\n우선순위 큐\n\n큐의 기본 연산\n\nenqueue (삽입)\ndequeue (삭제)\npeek (조회)\n\n큐의 활용 사례\n\n프로세스 스케줄링\n데이터 스트림 처리\n\n배열과 연결 리스트로 구현하는 큐\n큐 사용 예제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#트리-tree",
    "href": "index.html#트리-tree",
    "title": "자료구조",
    "section": "트리 (Tree)",
    "text": "트리 (Tree)\n\n트리의 개념과 구조\n트리의 기본 용어\n\n노드, 루트, 리프, 부모/자식 노드, 서브트리\n\n이진 트리와 이진 탐색 트리\n트리 순회 방법\n\n전위 순회\n중위 순회\n후위 순회\n\n균형 트리 (AVL 트리, 레드-블랙 트리)\n힙(Heap)과 힙 정렬\n트리의 활용 사례\n\n폴더 구조\n데이터베이스 인덱싱\n\n트리 사용 예제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#그래프-graph",
    "href": "index.html#그래프-graph",
    "title": "자료구조",
    "section": "그래프 (Graph)",
    "text": "그래프 (Graph)\n\n그래프의 개념과 구조\n그래프의 기본 용어\n\n정점(Vertex), 간선(Edge)\n방향 그래프와 무방향 그래프\n가중치 그래프\n\n그래프 표현 방법\n\n인접 행렬\n인접 리스트\n\n그래프 탐색 알고리즘\n\n깊이 우선 탐색(DFS)\n너비 우선 탐색(BFS)\n\n최소 신장 트리 (MST)\n\n크루스칼 알고리즘\n프림 알고리즘\n\n최단 경로 알고리즘\n\n다익스트라 알고리즘\n플로이드-워셜 알고리즘\n\n그래프의 활용 사례\n\n네트워크 경로 찾기\n소셜 네트워크 분석\n\n그래프 사용 예제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#자료구조-비교-및-선택-기준",
    "href": "index.html#자료구조-비교-및-선택-기준",
    "title": "자료구조",
    "section": "자료구조 비교 및 선택 기준",
    "text": "자료구조 비교 및 선택 기준\n\n상황별 자료구조 선택 가이드\n시간 복잡도와 공간 복잡도 비교",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#자료구조-실전-문제",
    "href": "index.html#자료구조-실전-문제",
    "title": "자료구조",
    "section": "9. 자료구조 실전 문제",
    "text": "9. 자료구조 실전 문제\n\n기본 개념 복습 문제\n단계별 실습 문제\n응용 및 심화 문제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "index.html#부록",
    "href": "index.html#부록",
    "title": "자료구조",
    "section": "10. 부록",
    "text": "10. 부록\n\n빅오 표기법(Big-O Notation) 설명\n참고할 만한 추가 자료 및 학습 사이트",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>들어가기</span>"
    ]
  },
  {
    "objectID": "00datastructure.html",
    "href": "00datastructure.html",
    "title": "자료구조란 무엇인가?",
    "section": "",
    "text": "자료구조의 정의와 중요성\n자료구조(Data Structure)란 데이터를 효율적으로 저장하고, 관리하며, 처리하기 위한 방법과 그 구조를 의미한다. 즉, 데이터를 특정한 방식으로 조직화하여 필요한 작업(삽입, 삭제, 검색 등)을 쉽게 수행할 수 있도록 하는 체계이다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>자료구조란 무엇인가?</span>"
    ]
  },
  {
    "objectID": "00datastructure.html#자료구조의-정의와-중요성",
    "href": "00datastructure.html#자료구조의-정의와-중요성",
    "title": "자료구조란 무엇인가?",
    "section": "",
    "text": "자료구조의 중요성\n\n효율적인 데이터 관리\n프로그램에서 데이터를 효과적으로 저장하고, 필요한 정보를 빠르게 찾아 사용할 수 있도록 한다. 예를 들어, 전화번호부에서 사람의 이름으로 번호를 찾는 경우 배열보다는 트리 구조를 사용하는 것이 더 빠를 수 있다.\n예제: 전화번호부 검색 배열을 사용해 이름과 전화번호를 저장할 수 있지만, 검색 속도가 느리다. 대신 이진 탐색 트리(Binary Search Tree)를 사용하면 이름을 기준으로 데이터를 정렬하여 검색 속도를 빠르게 할 수 있다. 예를 들어, 1000명의 이름 중 특정 이름을 찾을 때, 배열은 최대 1000번의 비교가 필요하지만, 이진 탐색 트리는 약 10번의 비교로 찾을 수 있다.\n성능 최적화\n잘 설계된 자료구조는 프로그램의 실행 속도와 메모리 사용량을 최적화할 수 있다. 같은 문제라도 어떤 자료구조를 사용하느냐에 따라 실행 시간이 크게 달라질 수 있다.\n예제: 대용량 데이터 검색\n대규모 데이터셋(예: 수백만 개의 사용자 정보)에서 특정 사용자를 검색할 때, 해시 테이블(Hash Table)을 사용하면 검색 속도가 평균적으로 O(1)에 수렴하여 매우 빠르다. 반면, 배열이나 연결 리스트를 사용하면 O(n)의 시간이 소요되어 성능이 저하된다. 예를 들어, 해시 테이블을 사용한 사전(dictionary) 검색은 거의 즉각적인 결과를 제공한다.\n복잡한 문제 해결\n복잡한 문제를 단순하게 표현하고 해결할 수 있는 도구로 사용된다. 예를 들어, 그래프 자료구조를 이용하면 소셜 네트워크 분석이나 경로 탐색 같은 복잡한 문제를 효율적으로 해결할 수 있다.\n예제: 최단 경로 찾기\n도시 간의 최단 경로를 찾는 문제에서 그래프(Graph) 자료구조를 사용하여 도시(정점)와 도로(간선)를 표현할 수 있다. 그런 다음, 다익스트라 알고리즘(Dijkstra’s Algorithm)을 활용하여 출발지에서 목적지까지의 최단 경로를 효율적으로 계산할 수 있다. 이 방법은 네비게이션 시스템에서 주로 사용된다.\n재사용성과 유지보수성 향상\n자료구조는 코드의 가독성을 높이고, 유지보수를 쉽게 만들어준다. 잘 설계된 자료구조는 다양한 프로그램에서 재사용할 수 있다.\n예제: 웹 브라우저의 뒤로 가기 기능\n웹 브라우저에서 방문한 페이지의 기록을 저장하는 데 스택(Stack) 자료구조를 사용하면, ‘뒤로 가기’ 버튼을 클릭할 때 마지막에 방문한 페이지부터 순차적으로 이전 페이지로 돌아갈 수 있다. 이 구조는 다른 프로그램(예: 텍스트 편집기의 실행 취소 기능)에서도 쉽게 재사용할 수 있다. 스택을 사용하면 기능을 추가하거나 수정하는 것도 간단하다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>자료구조란 무엇인가?</span>"
    ]
  },
  {
    "objectID": "00datastructure.html#자료구조와-알고리즘의-관계",
    "href": "00datastructure.html#자료구조와-알고리즘의-관계",
    "title": "자료구조란 무엇인가?",
    "section": "자료구조와 알고리즘의 관계",
    "text": "자료구조와 알고리즘의 관계\n알고리즘(Algorithm)은 문제를 해결하기 위한 일련의 절차나 방법을 의미하며, 자료구조는 이 알고리즘이 데이터를 효율적으로 처리할 수 있도록 돕는 도구이다. 이 둘은 밀접한 관계를 가지며, 상호 보완적으로 작동한다.\n\n관계의 핵심\n\n자료구조는 데이터를 저장, 알고리즘은 데이터를 처리\n자료구조는 데이터를 어떻게 저장하고 조직화할지 결정하며, 알고리즘은 그 데이터를 어떻게 처리하고 조작할지를 결정한다. 예를 들어, 정렬 알고리즘은 배열이나 리스트 같은 자료구조에 저장된 데이터를 기준으로 동작한다.\n자료구조에 따라 알고리즘의 효율성이 달라짐\n같은 문제라도 어떤 자료구조를 선택하느냐에 따라 알고리즘의 성능이 달라진다. 예를 들어, 검색 문제를 해결할 때, 배열을 사용하면 선형 탐색(linear search)을 해야 하지만, 이진 탐색 트리를 사용하면 훨씬 더 빠르게 검색할 수 있다.\n알고리즘 설계 시 자료구조 고려\n알고리즘을 설계할 때 적절한 자료구조를 선택하는 것이 중요하다. 예를 들어, 깊이 우선 탐색(DFS) 알고리즘을 구현할 때 스택 자료구조를 활용하고, 너비 우선 탐색(BFS) 알고리즘은 큐 자료구조를 활용한다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>자료구조란 무엇인가?</span>"
    ]
  },
  {
    "objectID": "00datastructure.html#자료구조-선택의-기준",
    "href": "00datastructure.html#자료구조-선택의-기준",
    "title": "자료구조란 무엇인가?",
    "section": "자료구조 선택의 기준",
    "text": "자료구조 선택의 기준\n효율적인 프로그램을 작성하기 위해서는 문제에 맞는 적절한 자료구조를 선택해야 한다. 자료구조 선택은 프로그램의 성능과 자원 사용에 큰 영향을 미친다.\n\n자료구조 선택 시 고려할 요소\n\n데이터의 크기와 형태\n저장해야 하는 데이터의 크기(고정 크기 또는 동적 크기)와 형태(단순한 값, 복합 구조 등)에 따라 자료구조를 선택해야 한다. 예를 들어, 고정된 크기의 데이터에는 배열이 적합하고, 크기가 자주 변하는 데이터에는 연결 리스트가 유용하다.\n데이터 접근 방식\n데이터에 얼마나 자주 접근하고, 어떤 방식으로 접근하는지가 중요하다.\n\n순차 접근이 필요한 경우 리스트나 큐가 적합하다.\n임의 접근(random access)이 필요하다면 배열이 유리하다.\n계층적 구조로 데이터를 관리해야 한다면 트리를 사용할 수 있다.\n\n삽입, 삭제, 검색의 빈도\n삽입, 삭제, 검색 작업의 빈도에 따라 자료구조를 선택한다.\n\n삽입과 삭제가 빈번한 경우 연결 리스트가 적합하다.\n빠른 검색이 필요하다면 해시 테이블이나 트리를 사용하는 것이 좋다.\n\n메모리 사용량\n사용할 수 있는 메모리의 제약에 따라 자료구조를 선택해야 한다. 예를 들어, 배열은 메모리를 연속적으로 할당하지만, 연결 리스트는 포인터를 사용하기 때문에 메모리 효율이 다르다.\n복잡도(시간 및 공간)\n자료구조가 제공하는 각 연산의 시간 복잡도와 공간 복잡도를 고려해야 한다. 아래 표는 주요 자료구조의 연산별 시간 복잡도를 비교한 것이다.\n\n\n\n자료구조\n접근 (Access)\n검색 (Search)\n삽입 (Insert)\n삭제 (Delete)\n\n\n\n\n배열\nO(1)\nO(n)\nO(n)\nO(n)\n\n\n연결 리스트\nO(n)\nO(n)\nO(1)\nO(1)\n\n\n스택\nO(n)\nO(n)\nO(1)\nO(1)\n\n\n큐\nO(n)\nO(n)\nO(1)\nO(1)\n\n\n해시 테이블\n-\nO(1)\nO(1)\nO(1)\n\n\n이진 탐색 트리\nO(log n)\nO(log n)\nO(log n)\nO(log n)\n\n\n\n문제의 특성과 요구사항\n문제의 특성과 요구사항(예: 실시간 데이터 처리, 대규모 데이터 처리)에 맞는 자료구조를 선택해야 한다. 예를 들어, 실시간 데이터 처리에는 큐나 덱(Deque), 우선순위 큐가 효과적이다.\n\n\n적절한 자료구조를 선택하는 것은 프로그램의 성능을 결정짓는 중요한 요소이며, 문제 해결의 효율성을 극대화하는 핵심적인 과정이다. 자료구조의 특성을 이해하고, 문제 상황에 맞는 최적의 구조를 선택하는 것이 중요하다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>자료구조란 무엇인가?</span>"
    ]
  },
  {
    "objectID": "10array.html",
    "href": "10array.html",
    "title": "배열",
    "section": "",
    "text": "배열의 개념과 구조\n배열(Array)은 같은 데이터 타입의 요소들이 연속적으로 저장된 데이터 구조이다. 배열은 각 요소에 인덱스(index)를 통해 접근할 수 있으며, 이 인덱스는 일반적으로 0부터 시작한다(인덱스 시작 기준에 따른 프로그래밍 언어 분류 참고).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "10array.html#배열의-개념과-구조",
    "href": "10array.html#배열의-개념과-구조",
    "title": "배열",
    "section": "",
    "text": "배열\n\n\n\n\n배열의 구조\n배열 구조는 연속된 공간에 동일한 데이터 타입을 갖는다.\n\n연속적인 메모리 공간: 배열은 메모리에 연속적으로 저장된다.\n\n인덱스 기반 접근: 배열의 각 요소는 고유한 인덱스를 통해 빠르게 접근할 수 있다.\n\n동일한 데이터 타입: 배열에 저장되는 모든 데이터는 동일한 타입을 가져야 한다.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "10array.html#배열의-특징",
    "href": "10array.html#배열의-특징",
    "title": "배열",
    "section": "배열의 특징",
    "text": "배열의 특징\n\n고정 크기\n배열은 생성 시 크기가 고정되며, 한 번 크기가 정해지면 변경할 수 없다. 이로 인해 메모리 관리가 효율적이지만, 크기를 미리 예측해야 하는 단점이 있다.\n\n# 배열 생성 (크기 고정)\nimport array \n\narr = array.array('i', [1, 2, 3, 4, 5])  # 'i'는 정수형 배열을 의미\nprint(arr)\n\narray('i', [1, 2, 3, 4, 5])\n\n\n\n\n인덱스를 통한 접근\n배열의 각 요소는 인덱스를 통해 O(1)의 시간 복잡도로 직접 접근할 수 있다.\n\n# 배열 요소 접근\nprint(arr[0])  # 첫 번째 요소 출력: 1\nprint(arr[3])  # 네 번째 요소 출력: 4\n\n1\n4",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "10array.html#배열의-종류",
    "href": "10array.html#배열의-종류",
    "title": "배열",
    "section": "배열의 종류",
    "text": "배열의 종류\n\n1차원 배열\n가장 기본적인 형태로, 일렬로 나열된 데이터의 집합이다.\n\n# 1차원 배열\narr = array.array('i', [10, 20, 30, 40, 50])\nprint(arr[2])  # 출력: 30\n\n30\n\n\n\n\n2차원 배열\n\n\n\n2차원 배열\n\n\n행(row)과 열(column)로 구성된 배열로, 테이블 형태의 데이터를 표현할 때 사용된다. 파이썬에서는 리스트의 리스트로 표현할 수 있다.\n\n# 2차원 배열\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nprint(matrix[1][2])  # 2번째 행, 3번째 열의 값 출력: 6\n\n6\n\n\n\n\n다차원 배열\n\n\n\n3차원 배열\n\n\n2차원 배열을 확장한 구조로, 3차원 이상의 복잡한 데이터를 저장할 때 사용된다. NumPy 라이브러리를 활용하면 쉽게 다차원 배열을 다룰 수 있다.\n\nimport numpy as np\n\n# 3차원 배열 생성\ntensor = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(tensor[1][0][1])  # 출력: 6\n\n6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "10array.html#배열의-기본-연산",
    "href": "10array.html#배열의-기본-연산",
    "title": "배열",
    "section": "배열의 기본 연산",
    "text": "배열의 기본 연산\n\n삽입 (Insert)\n배열의 특정 위치에 요소를 추가하는 작업이다. 배열의 크기가 고정된 경우, 삽입 시 요소를 이동시켜야 한다.\n\n# 배열에 값 삽입\narr.insert(2, 25)  # 인덱스 2에 25 삽입\nprint(arr)  # 출력: array('i', [10, 20, 25, 30, 40, 50])\n\narray('i', [10, 20, 25, 30, 40, 50])\n\n\n\n\n삭제 (Delete)\n배열에서 특정 요소를 제거하는 작업이다. 삭제 후 나머지 요소를 이동시켜야 한다.\n\n# 배열 요소 삭제\narr.remove(25)  # 값 25 삭제\nprint(arr)  # 출력: array('i', [10, 20, 30, 40, 50])\n\narray('i', [10, 20, 30, 40, 50])\n\n\n\n\n검색 (Search)\n배열에서 특정 값을 찾는 작업이다. 배열은 선형 검색(linear search)을 통해 O(n) 시간 복잡도로 검색할 수 있다.\n\n# 배열에서 값 검색\nindex = arr.index(40)  # 값 40의 인덱스 찾기\nprint(index)  # 출력: 3\n\n3\n\n\n\n\n수정 (Update)\n배열의 특정 인덱스에 저장된 값을 변경하는 작업이다. 인덱스를 통한 접근 덕분에 수정은 O(1) 시간 복잡도로 수행된다.\n\n# 배열 요소 수정\narr[1] = 15  # 인덱스 1의 값을 15로 변경\nprint(arr)  # 출력: array('i', [10, 15, 30, 40, 50])\n\narray('i', [10, 15, 30, 40, 50])",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "10array.html#배열의-장단점",
    "href": "10array.html#배열의-장단점",
    "title": "배열",
    "section": "배열의 장단점",
    "text": "배열의 장단점\n\n\n\n\n\n\n\n장점\n단점\n\n\n\n\n인덱스를 통한 빠른 접근 속도 (O(1))\n고정된 크기로 인해 유연성 부족\n\n\n메모리 상에 연속적인 저장으로 캐시 효율성 높음\n삽입/삭제 시 많은 요소 이동 필요\n\n\n단순한 구조로 구현 및 이해가 쉬움\n검색 속도가 느릴 수 있음 (O(n))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "10array.html#배열-사용-예제",
    "href": "10array.html#배열-사용-예제",
    "title": "배열",
    "section": "배열 사용 예제",
    "text": "배열 사용 예제\n\n예제 1: 학생 점수 평균 구하기\n배열을 활용하여 학생들의 점수를 저장하고, 평균을 계산하는 간단한 프로그램이다.\n\n# 학생 점수 평균 계산\nscores = array.array('i', [85, 90, 78, 92, 88])\n\n# 총합과 평균 계산\ntotal = sum(scores)\naverage = total / len(scores)\n\nprint(f'총합: {total}, 평균: {average}')\n\n총합: 433, 평균: 86.6\n\n\n\n\n예제 2: 최대값과 최소값 찾기\n배열에 저장된 값들 중 최대값과 최소값을 찾는 예제이다.\n\n# 최대값과 최소값 찾기\nmax_score = max(scores)\nmin_score = min(scores)\n\nprint(f'최대 점수: {max_score}, 최소 점수: {min_score}')\n\n최대 점수: 92, 최소 점수: 78\n\n\n\n\n예제 3: 2차원 배열로 행렬 덧셈\n2차원 배열을 활용하여 행렬 덧셈을 수행하는 예제이다.\n\n# 행렬 덧셈\nmatrix1 = [\n    [1, 2],\n    [3, 4]\n]\n\nmatrix2 = [\n    [5, 6],\n    [7, 8]\n]\n\n# 두 행렬의 덧셈 결과 저장\nresult = [\n    [matrix1[i][j] + matrix2[i][j] for j in range(2)]\n    for i in range(2)\n]\n\nprint(result)  # 출력: [[6, 8], [10, 12]]\n\n[[6, 8], [10, 12]]\n\n\n\n배열은 단순하면서도 강력한 자료구조로, 다양한 프로그래밍 문제에서 활용된다. 특히 데이터의 크기와 접근 방식에 따라 배열의 장점을 극대화할 수 있다.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "10array.html#참고자료",
    "href": "10array.html#참고자료",
    "title": "배열",
    "section": "참고자료",
    "text": "참고자료\n\n인덱스 시작 기준에 따른 프로그래밍 언어 분류\n\n\n\n\n\n\n\n인덱스 0부터 시작하는 언어\n인덱스 1부터 시작하는 언어\n\n\n\n\nC\nFortran\n\n\nC++\nMATLAB\n\n\nJava\nLua\n\n\nPython\nR\n\n\nJavaScript\nJulia\n\n\nRuby\nCOBOL\n\n\nSwift\nSmalltalk\n\n\nGo\nPascal (일부 구현체)\n\n\nKotlin\nVisual Basic\n\n\nPHP\nALGOL\n\n\nRust\nAda\n\n\nTypeScript\nMathematica\n\n\n\n\n설명\n\n인덱스 0부터 시작하는 언어: 메모리 주소 기반의 접근 방식을 사용하는 언어들이 대부분 0부터 인덱스를 시작한다. 이는 배열의 첫 번째 요소가 배열의 시작 주소와 일치하기 때문에 효율적인 메모리 관리가 가능하다.\n\n예: C, Python 등\n\n인덱스 1부터 시작하는 언어: 수학적 배열이나 행렬의 표현 방식을 따르는 언어들이 1부터 인덱스를 시작한다. 이는 수학적 직관성을 높여준다.\n\n예: MATLAB, R 등\n\n\n언어에 따라 인덱스 시작 방식을 다르게 설정할 수 있는 경우도 있으며, 사용자 설정에 따라 인덱스를 변경할 수 있는 언어도 있다.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>배열</span>"
    ]
  },
  {
    "objectID": "20linkedlist.html",
    "href": "20linkedlist.html",
    "title": "연결 리스트 (Linked List)",
    "section": "",
    "text": "연결 리스트의 개념과 구조\n연결 리스트(Linked List)는 데이터를 노드(Node)라는 단위로 저장하고, 각 노드가 다음 노드의 주소(참조)를 저장하는 자료구조이다. 배열과 달리 연결 리스트는 메모리 상에서 연속적이지 않은 위치에 데이터를 저장하며, 필요에 따라 크기를 동적으로 확장하거나 축소할 수 있다.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>연결 리스트 (Linked List)</span>"
    ]
  },
  {
    "objectID": "20linkedlist.html#연결-리스트의-개념과-구조",
    "href": "20linkedlist.html#연결-리스트의-개념과-구조",
    "title": "연결 리스트 (Linked List)",
    "section": "",
    "text": "연결 리스트의 구조\n\n\n\n연결 리스트\n\n\n\n노드(Node): 데이터와 다음 노드에 대한 참조(포인터)로 구성된다.\n\n데이터(data): 저장되는 실제 값\n포인터(next): 다음 노드를 가리키는 참조\n\n헤드(Head): 연결 리스트의 첫 번째 노드를 가리키는 포인터\n테일(Tail): 리스트의 마지막 노드로, 다음 노드가 없는 상태 (일반적으로 None으로 표시)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>연결 리스트 (Linked List)</span>"
    ]
  },
  {
    "objectID": "20linkedlist.html#연결-리스트의-종류",
    "href": "20linkedlist.html#연결-리스트의-종류",
    "title": "연결 리스트 (Linked List)",
    "section": "연결 리스트의 종류",
    "text": "연결 리스트의 종류\n\n단일 연결 리스트 (Singly Linked List)\n각 노드가 다음 노드에 대한 참조만을 가지는 가장 기본적인 형태의 연결 리스트이다.\n\n특징\n\n\n한 방향으로만 순회 가능\n마지막 노드의 next는 None을 가리킴\n\n\n\n\n# 단일 연결 리스트 구현\n\nclass Node:\n    def __init__(self, data):\n        self.data = data  # 데이터 저장\n        self.next = None  # 다음 노드 초기화\n\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None  # 첫 번째 노드(헤드)\n\n    # insert node _____________________________________________\n    def insert_at_beginning(self, data):\n        new_node = Node(data)\n        new_node.next = self.head  # 새 노드가 기존 첫 노드를 가리킴\n        self.head = new_node       # 헤드를 새 노드로 변경\n\n    # delete node _____________________________________________\n    def delete(self, key):\n        current = self.head\n    \n        # 첫 노드가 삭제 대상인 경우\n        if current and current.data == key:\n            self.head = current.next\n            return\n    \n        prev = None\n        while current and current.data != key:\n            prev = current\n            current = current.next\n    \n        if current is None:\n            return  # 삭제할 값이 없는 경우\n    \n        prev.next = current.next  # 노드 삭제\n\n    # search node _____________________________________________\n    def search(self, key):\n        current = self.head\n        while current:\n            if current.data == key:\n                return True\n            current = current.next\n        return False\n\n    # append node _____________________________________________\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node  # 리스트가 비어있으면 첫 노드로 설정\n            return\n        current = self.head\n        while current.next:\n            current = current.next  # 마지막 노드 찾기\n        current.next = new_node  # 새 노드 연결\n\n    # display node _____________________________________________\n    def display(self):\n        current = self.head\n        while current:\n            print(current.data, end=' → ')\n            current = current.next\n        print('None')\n\n# 사용 예제\nsll = SinglyLinkedList()\nsll.append(10)\nsll.append(20)\nsll.append(30)\nsll.display()  # 출력: 10 → 20 → 30 → None\n\n10 → 20 → 30 → None\n\n\n\n\n\n이중 연결 리스트 (Doubly Linked List)\n\n\n\n이중 연결 리스트\n\n\n각 노드가 이전 노드(prev)와 다음 노드(next)에 대한 참조를 모두 가지는 연결 리스트이다.\n\n특징\n\n\n앞뒤로 순회 가능\n삽입/삭제 시 더 유연하게 동작\n\n\n\n\n# 이중 연결 리스트 구현\n\nclass DNode:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None  # 이전 노드 참조\n        self.next = None  # 다음 노드 참조\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = DNode(data)\n        if not self.head:\n            self.head = new_node\n            return\n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = new_node\n        new_node.prev = current  # 이전 노드 설정\n\n    def display(self):\n        current = self.head\n        while current:\n            print(current.data, end=' ↔ ')\n            current = current.next\n        print('None')\n\n# 사용 예제\ndll = DoublyLinkedList()\ndll.append(10)\ndll.append(20)\ndll.append(30)\ndll.display()  # 출력: 10 ↔ 20 ↔ 30 ↔ None\n\n10 ↔ 20 ↔ 30 ↔ None\n\n\n\n\n\n환형 연결 리스트 (Circular Linked List)\n\n\n\n환형 연결 리스트\n\n\n리스트의 마지막 노드가 처음 노드(헤드)를 가리키는 형태로, 원형 구조를 이룬다.\n\n특징\n\n\n순환 구조로 인해 리스트의 끝이 없음\n특정 상황에서 무한 루프 방지 필요\n\n\n\n\n# 환형 연결 리스트 구현\n\nclass CNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = CNode(data)\n        if not self.head:\n            self.head = new_node\n            self.head.next = self.head  # 자기 자신을 가리킴\n            return\n        current = self.head\n        while current.next != self.head:\n            current = current.next\n        current.next = new_node\n        new_node.next = self.head  # 새 노드가 다시 헤드를 가리킴\n\n    def display(self):\n        if not self.head:\n            return\n        current = self.head\n        while True:\n            print(current.data, end=' → ')\n            current = current.next\n            if current == self.head:\n                break\n        print('(다시 시작)')\n\n# 사용 예제\ncll = CircularLinkedList()\ncll.append(10)\ncll.append(20)\ncll.append(30)\ncll.display()  # 출력: 10 → 20 → 30 → (다시 시작)\n\n10 → 20 → 30 → (다시 시작)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>연결 리스트 (Linked List)</span>"
    ]
  },
  {
    "objectID": "20linkedlist.html#연결-리스트의-기본-연산",
    "href": "20linkedlist.html#연결-리스트의-기본-연산",
    "title": "연결 리스트 (Linked List)",
    "section": "연결 리스트의 기본 연산",
    "text": "연결 리스트의 기본 연산\n\n삽입 (Insert)\n특정 위치에 새로운 노드를 추가하는 작업이다.\n\n단일 연결 리스트에서 삽입\n\n\"\"\"\nin SinglyLinkedList\ndef insert_at_beginning(self, data):\n    new_node = Node(data)\n    new_node.next = self.head  # 새 노드가 기존 첫 노드를 가리킴\n    self.head = new_node       # 헤드를 새 노드로 변경\n\"\"\"\n# 사용 예제\nsll.insert_at_beginning(5)\nsll.display()  # 출력: 5 → 10 → 20 → 30 → None\n\n5 → 10 → 20 → 30 → None\n\n\n\n\n\n삭제 (Delete)\n특정 노드를 삭제하는 작업이다.\n\n예제 (단일 연결 리스트에서 삭제)\n\n\"\"\"\ndef delete(self, key):\n    current = self.head\n\n    # 첫 노드가 삭제 대상인 경우\n    if current and current.data == key:\n        self.head = current.next\n        return\n\n    prev = None\n    while current and current.data != key:\n        prev = current\n        current = current.next\n\n    if current is None:\n        return  # 삭제할 값이 없는 경우\n\n    prev.next = current.next  # 노드 삭제\n\"\"\"\n# 사용 예제\nsll.delete(20)\nsll.display()  # 출력: 5 → 10 → 30 → None\n\n5 → 10 → 30 → None\n\n\n\n\n\n검색 (Search)\n리스트에서 특정 값을 찾는 작업이다.\n예제 (단일 연결 리스트에서 검색)\n\n\"\"\"\ndef search(self, key):\n    current = self.head\n    while current:\n        if current.data == key:\n            return True\n        current = current.next\n    return False\n\"\"\"\n\n# 사용 예제\nprint(sll.search(30))  # 출력: True\nprint(sll.search(50))  # 출력: False\n\nTrue\nFalse",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>연결 리스트 (Linked List)</span>"
    ]
  },
  {
    "objectID": "20linkedlist.html#배열과-연결-리스트의-비교",
    "href": "20linkedlist.html#배열과-연결-리스트의-비교",
    "title": "연결 리스트 (Linked List)",
    "section": "배열과 연결 리스트의 비교",
    "text": "배열과 연결 리스트의 비교\n\n\n\n\n\n\n\n\n구분\n배열 (Array)\n연결 리스트 (Linked List)\n\n\n\n\n메모리 구조\n연속적인 메모리 공간\n비연속적인 메모리 공간\n\n\n크기\n고정 크기\n동적 크기 조정 가능\n\n\n접근 속도\n인덱스를 통한 빠른 접근 (O(1))\n순차 접근 필요 (O(n))\n\n\n삽입/삭제\n중간 삽입/삭제 시 데이터 이동 필요 (O(n))\n포인터 변경만으로 삽입/삭제 가능 (O(1) ~ O(n))\n\n\n메모리 사용\n고정된 크기로 인해 메모리 낭비 가능\n필요한 만큼만 메모리 사용",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>연결 리스트 (Linked List)</span>"
    ]
  },
  {
    "objectID": "20linkedlist.html#연결-리스트-사용-예제",
    "href": "20linkedlist.html#연결-리스트-사용-예제",
    "title": "연결 리스트 (Linked List)",
    "section": "연결 리스트 사용 예제",
    "text": "연결 리스트 사용 예제\n\n예제 1: 히스토리 기능 구현 (이중 연결 리스트)\n웹 브라우저의 ‘뒤로 가기’ 및 ‘앞으로 가기’ 기능을 이중 연결 리스트로 구현할 수 있다.\n예제 코드\n\n# 간단한 웹 브라우저 히스토리 기능\ndll.append('페이지1')\ndll.append('페이지2')\ndll.append('페이지3')\n\ncurrent = dll.head.next  # '페이지2' 위치\n\n# 뒤로 가기\nif current.prev:\n    current = current.prev\n    print(f'뒤로 가기: {current.data}')  # 출력: 페이지1\n\n# 앞으로 가기\nif current.next:\n    current = current.next\n    print(f'앞으로 가기: {current.data}')  # 출력: 페이지2\n\n뒤로 가기: 10\n앞으로 가기: 20\n\n\n\n\n예제 2: 순환 작업 (환형 연결 리스트)\n게임에서 플레이어의 턴을 순환적으로 처리하는 시스템에 활용 가능하다.\n예제 코드\n\n# 게임 플레이어 턴 관리\ncll.append('플레이어1')\ncll.append('플레이어2')\ncll.append('플레이어3')\n\ncurrent = cll.head\nfor _ in range(5):  # 5번 턴 진행\n    print(f'{current.data}의 턴입니다.')\n    current = current.next\n\n10의 턴입니다.\n20의 턴입니다.\n30의 턴입니다.\n플레이어1의 턴입니다.\n플레이어2의 턴입니다.\n\n\n이러한 예제들은 연결 리스트의 유연성과 다양한 활용 가능성을 보여준다. 적절한 연결 리스트의 종류를 선택하면 문제 해결에 큰 도움이 된다.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>연결 리스트 (Linked List)</span>"
    ]
  },
  {
    "objectID": "30stack.html",
    "href": "30stack.html",
    "title": "스택(Stack)",
    "section": "",
    "text": "스택의 개념과 구조\n스택(Stack)은 데이터를 쌓는 형태로 저장하는 자료구조로, LIFO(Last In First Out) 원칙을 따른다. 즉, 가장 나중에 추가된 데이터가 가장 먼저 제거되는 구조이다. 스택은 한쪽 끝에서만 데이터의 삽입과 삭제가 이루어지며, 이 끝 부분을 Top(탑)이라고 한다.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  },
  {
    "objectID": "30stack.html#스택의-개념과-구조",
    "href": "30stack.html#스택의-개념과-구조",
    "title": "스택(Stack)",
    "section": "",
    "text": "스택",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  },
  {
    "objectID": "30stack.html#lifo-last-in-first-out-원리",
    "href": "30stack.html#lifo-last-in-first-out-원리",
    "title": "스택(Stack)",
    "section": "LIFO (Last In First Out) 원리",
    "text": "LIFO (Last In First Out) 원리\nLIFO란 마지막에 들어간 데이터가 가장 먼저 나온다는 의미다.\n\n실생활 예시\n\n\n접시 쌓기: 가장 나중에 올린 접시를 먼저 꺼내는 방식\n책 더미: 가장 위에 놓인 책을 먼저 꺼내 읽는 방식",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  },
  {
    "objectID": "30stack.html#스택의-기본-연산",
    "href": "30stack.html#스택의-기본-연산",
    "title": "스택(Stack)",
    "section": "스택의 기본 연산",
    "text": "스택의 기본 연산\n\npush (삽입)\n\n\n스택의 Top에 새로운 데이터를 추가하는 연산\n\n\npop (삭제)\n\n\n스택의 Top에 있는 데이터를 제거하고 반환하는 연산, 만약 스택이 비어있다면 오류를 발생\n\n\npeek (조회)\n\n\n스택의 Top에 있는 데이터를 제거하지 않고 확인하는 연산",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  },
  {
    "objectID": "30stack.html#스택의-파이썬-구현",
    "href": "30stack.html#스택의-파이썬-구현",
    "title": "스택(Stack)",
    "section": "스택의 파이썬 구현",
    "text": "스택의 파이썬 구현\n\n리스트(List)를 이용한 스택 구현\n파이썬의 리스트 자료형을 사용하면 쉽게 스택을 구현할 수 있다.\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, data):\n        self.stack.append(data)\n\n    def pop(self):\n        if self.is_empty():\n            return \"스택이 비어있습니다.\"\n        return self.stack.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return \"스택이 비어있습니다.\"\n        return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n    def size(self):\n        return len(self.stack)\n\n# 사용 예제\ns = Stack()\ns.push(10)\ns.push(20)\ns.push(30)\nprint(s.peek())  # 출력: 30\nprint(s.pop())   # 출력: 30\nprint(s.pop())   # 출력: 20\nprint(s.peek())  # 출력: 10\n\n30\n30\n20\n10",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  },
  {
    "objectID": "30stack.html#스택의-활용-사례",
    "href": "30stack.html#스택의-활용-사례",
    "title": "스택(Stack)",
    "section": "스택의 활용 사례",
    "text": "스택의 활용 사례\n\n괄호 검사 (문법 체크)\n스택은 프로그래밍 언어의 괄호 짝 맞추기와 같은 문제 해결에 유용하게 사용된다. 여는 괄호를 만나면 스택에 넣고, 닫는 괄호를 만나면 스택에서 꺼내어 짝이 맞는지 검사한다.\n파이썬 예제 코드\n\ndef is_balanced(expression):\n    stack = Stack()\n    for char in expression:\n        if char in \"({[\":\n            stack.push(char)\n        elif char in \")}]\":\n            if stack.is_empty():\n                return False\n            top = stack.pop()\n            if not ((top == '(' and char == ')') or\n                    (top == '{' and char == '}') or\n                    (top == '[' and char == ']')):\n                return False\n    return stack.is_empty()\n\n# 사용 예제\nexpr1 = \"(a + b) * (c + d)\"\nexpr2 = \"(a + b * (c - d)\"\nprint(is_balanced(expr1))  # 출력: True\nprint(is_balanced(expr2))  # 출력: False\n\nTrue\nFalse\n\n\n\n\n\n함수 호출 관리 (콜 스택)\n프로그래밍 언어에서 함수 호출 시 호출된 함수와 복귀 위치를 관리하기 위해 콜 스택(Call Stack)을 사용한다.\n예제 설명\n재귀 함수 호출 시, 스택을 통해 호출된 함수가 쌓이고, 가장 마지막 함수부터 실행이 완료된 후 차례로 이전 함수로 돌아간다.\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n - 1)\n\n# 사용 예제\nprint(factorial(5))  # 출력: 120\n\n120\n\n\n\n호출 스택 흐름\nfactorial(5)\nfactorial(4)\nfactorial(3)\nfactorial(2)\nfactorial(1) → 반환 시작",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  },
  {
    "objectID": "30stack.html#배열과-연결-리스트로-구현하는-스택",
    "href": "30stack.html#배열과-연결-리스트로-구현하는-스택",
    "title": "스택(Stack)",
    "section": "배열과 연결 리스트로 구현하는 스택",
    "text": "배열과 연결 리스트로 구현하는 스택\n\n\n\n\n\n\n\n\n구현 방법\n배열 (List)\n연결 리스트\n\n\n\n\n메모리 구조\n연속적인 메모리 공간\n비연속적인 메모리 공간\n\n\n삽입/삭제 속도\n리스트의 끝에서 삽입/삭제 시 O(1) 성능 유지\n항상 O(1) 성능 유지\n\n\n메모리 효율성\n크기 조정이 필요할 때 리사이징으로 메모리 낭비 발생 가능\n필요한 만큼 동적으로 메모리 할당\n\n\n구현 복잡도\n간단한 구현\n포인터 관리로 인해 복잡도가 높음\n\n\n\n\n\n배열 기반 스택\n\n\n리스트 기반으로 앞서 구현한 스택과 동일하다.\n\n\n연결 리스트 기반 스택\n\n\n연결 리스트의 Head 부분을 스택의 Top으로 사용하여 구현할 수 있다.\n\n\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedListStack:\n    def __init__(self):\n        self.head = None\n\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def pop(self):\n        if self.is_empty():\n            return \"스택이 비어있습니다.\"\n        data = self.head.data\n        self.head = self.head.next\n        return data\n\n    def peek(self):\n        if self.is_empty():\n            return \"스택이 비어있습니다.\"\n        return self.head.data\n\n    def is_empty(self):\n        return self.head is None\n\n# 사용 예제\nll_stack = LinkedListStack()\nll_stack.push(100)\nll_stack.push(200)\nprint(ll_stack.peek())  # 출력: 200\nprint(ll_stack.pop())   # 출력: 200\nprint(ll_stack.pop())   # 출력: 100\n\n200\n200\n100",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  },
  {
    "objectID": "30stack.html#스택-사용-예제",
    "href": "30stack.html#스택-사용-예제",
    "title": "스택(Stack)",
    "section": "스택 사용 예제",
    "text": "스택 사용 예제\n\n문자열 뒤집기\n스택의 LIFO 특성을 이용하여 문자열을 뒤집는 작업을 수행할 수 있다.\n\ndef reverse_string(s):\n    stack = Stack()\n    for char in s:\n        stack.push(char)\n    \n    reversed_str = \"\"\n    while not stack.is_empty():\n        reversed_str += stack.pop()\n    \n    return reversed_str\n\n# 사용 예제\noriginal = \"hello\"\nprint(reverse_string(original))  # 출력: olleh\n\nolleh\n\n\n\n\n\nDFS(깊이 우선 탐색) 구현\n그래프 탐색 알고리즘 중 하나인 DFS(Depth-First Search)는 스택을 활용하여 구현할 수 있다.\n\n\n\n\n\ngraph TD\n    A --&gt; B\n    A --&gt; C\n    B --&gt; E\n    B --&gt; D\n    C --&gt; F\n    E --&gt; F\n\n\n\n\n\n\n\ndef dfs(graph, start):\n    visited = set()\n    stack = Stack()\n    stack.push(start)\n    \n    while not stack.is_empty():\n        vertex = stack.pop()\n        if vertex not in visited:\n            print(vertex, end=' ')\n            visited.add(vertex)\n            for neighbor in reversed(graph[vertex]):  # 인접 노드 스택에 삽입\n                stack.push(neighbor)\n\n# 그래프 인접 리스트 표현\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F'],\n    'D': [],\n    'E': ['F'],\n    'F': []\n}\n\n# 사용 예제\ndfs(graph, 'A')\n\nA B D E F C \n\n\n\n이처럼 스택은 간단하지만 매우 강력한 자료구조로, 다양한 알고리즘과 문제 해결에 활용된다. 특히 재귀적 문제 해결, 문법 검사, 그래프 탐색 등에서 필수적으로 사용된다.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>스택(Stack)</span>"
    ]
  }
]